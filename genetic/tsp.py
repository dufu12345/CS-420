# -*- coding: utf-8 -*-
"""TSP_Scavange.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1khTFJNm3d1VADeBKMuQ8nM-rqqCSg1zT
"""

def graph_cities(dictionary):
    """
    Graph the cities in a dictionary {'City1': (a, b), ...}
    Extract coordinates and labels from the dictionary
    Used for preliminary visualization of problem
    """
    x = [loc[0] for loc in dictionary.values()]
    y = [loc[1] for loc in dictionary.values()]
    labels = list(dictionary.keys())

    # Create the scatter plot
    plt.figure(figsize=(5, 5))
    plt.scatter(x, y)

    # Add labels to the points
    for i, label in enumerate(labels):
        plt.annotate(label, (x[i], y[i]))

    plt.title('Location Graph')
    plt.xlabel('X-coordinate')
    plt.ylabel('Y-coordinate')

    plt.show()

##Creating graph of regular polygon with cities A_i to use as test case/benchmark


def poly_dict(n):
    """
    Create a dictionary of vertices for a regular polygon with 'n' sides.
    The vertices are labeled as 'A_1' to 'A_n'.
    Each vertex is represented as a tuple (x, y) with coordinates.
    """
    if n <= 0:
        raise ValueError("n must be a positive integer.")
    
    center_x, center_y = 50, 50  # New center
    radius = 50  # New radius
    
    angles = [2 * math.pi * i / n for i in range(n)]
    
    vertices = {}
    for i, angle in enumerate(angles):
        x = round(center_x + radius * math.cos(angle), 3)
        y = round(center_y + radius * math.sin(angle), 3)
        vertex_name = 'A_{}'.format(i + 1)
        vertices[vertex_name] = (x, y)
    
    return vertices


def compute_city_distance_names(city_a, city_b, cities_dict):
    """
    Compute the Euclidean distance between two cities given their names.

    Parameters:
    city_a (str): Name of the first city.
    city_b (str): Name of the second city.
    cities_dict (dict): The dictionary mapping city names to their coordinates.

    Returns:
    float: The Euclidean distance between the two cities.
    """
    coord_a = cities_dict[city_a]
    coord_b = cities_dict[city_b]

    return np.hypot(coord_a[0] - coord_b[0], coord_a[1] - coord_b[1])

def genesis(city_list, PopulationSize, n_cities):
    """
    Create the first population set by randomly generating solutions.
    Returns:
    numpy.ndarray: An array of randomly generated populations.
    """
    return np.array([np.random.choice(city_list, n_cities, replace=False) for _ in range(PopulationSize)])

##Define a function to evaluate the fitness of an individual
##An individual is an ordering of the cities
##In other words fitness_eval, calculates the length of the circuit represented by the city ordering

def fitness_eval(city_list, cities_dict):
    """
    Evaluate the fitness of a solution by computing the total distance traveled.

    Parameters:
    city_list (list): The list of cities in the order they are visited.
    cities_dict (dict): The dictionary mapping city names to their coordinates.

    Returns:
    float: The total distance traveled.
    """
    # Create pairs of cities (current and next)
    city_pairs = zip(city_list[:-1], city_list[1:])

    # Calculate total distance for all city pairs
    total = np.sum([compute_city_distance_names(a, b, cities_dict) for a, b in city_pairs])

    # Add distance between last city and first city
    total += compute_city_distance_names(city_list[-1], city_list[0], cities_dict)

    return total


def get_all_fitness(Population, cities_dict):
    """
    Compute the fitness for each solution in the chromosone set.

    Parameters:
    Population (numpy.ndarray): An array of chromosomes.
    cities_dict (dict): A dictionary mapping city names to their coordinates.

    Returns:
    numpy.ndarray: An array of fitness values for each chromosome.
    """
    PopulationSize = len(Population)
    return np.array([fitness_eval(Population[i], cities_dict) for i in range(PopulationSize)])

def progenitor_selection(Population, fitness_list, ProgenitorPoolSize):
    """
    Select progenitors from the population using the roulette wheel method.

    Parameters:
    Population (list): A list of individuals (chromosomes).
    fitness_list (numpy.ndarray): An array of fitness values for each individual.
    ProgenitorPoolSize (int): The desired number of progenitors to select.

    Returns:
    list: A list of selected progenitors.
    """
    reversed_fitness = np.max(fitness_list) - fitness_list
    probabilities = reversed_fitness / np.sum(reversed_fitness)

    selected_indices = np.random.choice(range(len(Population)), size=ProgenitorPoolSize, replace=True, p=probabilities)
    selected_progenitors = [Population[i] for i in selected_indices]

    return selected_progenitors

def mate_progenitors(prog_a, prog_b):
    """
    Mates two progenitors to create an offspring.

    Parameters:
    prog_a (numpy.ndarray): The first progenitor.
    prog_b (numpy.ndarray): The second progenitor.

    Returns:
    numpy.ndarray: The offspring of the two progenitors.
    """
    # Randomly select a range for the first parent
    start_pos = np.random.randint(0, len(prog_a))
    end_pos = np.random.randint(start_pos, len(prog_a))

    # Get the cities in the selected range from the first parent
    offspring = list(prog_a[start_pos:end_pos])

    # Get the cities from the second parent that are not already in the offspring, keeping their order
    additional_cities = [city for city in prog_b if city not in offspring]

    # Combine the cities from both parents
    offspring = offspring + additional_cities

    return np.array(offspring)

def mate_selected_progenitors(selected_progenitors, ProgenitorPoolSize):
    """
    Mate selected progenitors to create offspring.

    Parameters:
    selected_progenitors (list): A list of selected progenitors.
    ProgenitorPoolSize (int): The number of progenitor pairs to mate.

    Returns:
    list: A list of offspring generated from mating the progenitor pairs.
    """
    Children = []

    for _ in range(ProgenitorPoolSize):
        # Randomly select two progenitors by their indices
        indices = np.random.choice(len(selected_progenitors), size=2, replace=False)
        prog_a, prog_b = selected_progenitors[indices[0]], selected_progenitors[indices[1]]

        # Mate the selected progenitors
        offspring = mate_progenitors(prog_a, prog_b)

        # Add the offspring to the list of children
        Children.append(offspring)

    return Children

def mutate_population(Population, MutationRate):
    """
    Performs mutation in the population by swapping two random cities in each individual selected for mutation.

    Parameters:
    Population (numpy.ndarray): An array of chromosomes (individuals).
    MutationRate (float): The rate of mutation.

    Returns:
    numpy.ndarray: The mutated population.
    """
    # Determine the number of individuals to mutate
    num_mutations = int(MutationRate * len(Population))

    # Select the individuals to mutate
    mutation_indices = np.random.choice(len(Population), size=num_mutations, replace=False)

    for index in mutation_indices:
        # Select two different positions in the individual
        swap_indices = np.random.choice(len(Population[index]), size=2, replace=False)

        # Swap the cities at the selected positions
        Population[index][swap_indices[0]], Population[index][swap_indices[1]] = Population[index][swap_indices[1]], Population[index][swap_indices[0]]

    return Population

def tournament_selection(Population, fitness_list, PopulationSize, TournamentSize):
    """
    Reduces the population size to PopulationSize by running tournaments. Each tournament consists of selecting 
    TournamentSize individuals from the augmented population and removing the one with the worst fitness.

    Parameters:
    Population (numpy.ndarray): The augmented population array.
    fitness_list (list): The list of fitness values of each individual in the augmented population.
    PopulationSize (int): The target size of the population.
    TournamentSize (int): The size of each tournament.
    
    Returns:
    numpy.ndarray: The reduced population array.
    """
    while len(Population) > PopulationSize:
        # Select TournamentSize individuals for the tournament
        tournament_indices = np.random.choice(len(Population), size=TournamentSize, replace=False)

        # Find the index of the individual with the worst fitness in the tournament
        worst_index = np.argmax(fitness_list[tournament_indices])

        # Remove the individual with the worst fitness from the population and fitness_list
        Population = np.delete(Population, tournament_indices[worst_index], axis=0)
        fitness_list = np.delete(fitness_list, tournament_indices[worst_index])

    return Population

def run_genetic_algo(n_generations, cities_dict, PopulationSize, ProgenitorPoolSize, MutationRate, TournamentSize):
    """
    Run a genetic algorithm for a given number of iterations (generations).

    Parameters:
    n_generations (int): The number of generations to run the genetic algorithm.
    PopulationSize (int): The size of the population.
    ProgenitorPoolSize (int): The number of progenitors to select in each generation.
    MutationRate (float): The rate of mutation.

    Returns:
    numpy.ndarray, float: The best solution found and its fitness value.
    """
    # Calculate n_cities, names_list and coordinates_list from cities_dict
    n_cities = len(cities_dict)
    names_list = list(cities_dict.keys())
    coordinates_list = list(cities_dict.values())

    # Create the initial population
    Population = genesis(names_list, PopulationSize, n_cities)

    # Initialize the best fitness to infinity (since we want to minimize fitness)
    best_fitness = np.inf
    # Initialize the best solution as None
    best_solution = None
    best_generation = 0
    
    # Initialize list to store best_fitness values and best solutions
    best_fitness_history = []
    best_solutions = []

    for generation in range(n_generations):
        # Evaluate the fitness of the current population
        fitness_list = get_all_fitness(Population, cities_dict)

        # Check if the best solution in the current population is better than the best solution found so far
        current_best_fitness = np.min(fitness_list)
        if current_best_fitness < best_fitness:
            best_fitness = current_best_fitness
            best_solution = Population[np.argmin(fitness_list)]
            best_generation = generation
            best_solutions.append((best_generation, best_solution))

        # Append the current best_fitness to the list every 100 generations
        if generation % 100 == 0:
            best_fitness_history.append((generation, best_fitness))
            print(f"Generation {generation}: Best Fitness = {best_fitness}")

        # Select progenitors for mating
        selected_progenitors = progenitor_selection(Population, fitness_list, ProgenitorPoolSize)

        # Generate children
        Children = mate_selected_progenitors(selected_progenitors, ProgenitorPoolSize)

        # Add Children to the Population
        Population = np.concatenate((Population, Children), axis=0)
        # Update fitness_list to include fitness of Children
        fitness_list = get_all_fitness(Population, cities_dict)

        # Reduce the size of Population to PopulationSize by running tournaments
        Population = tournament_selection(Population, fitness_list, PopulationSize, TournamentSize)
        # Update fitness_list for the reduced Population
        fitness_list = get_all_fitness(Population, cities_dict)

        # Mutate the population
        Population = mutate_population(Population, MutationRate)


    return best_solution, best_fitness, best_solutions

def run_naive_algo(n_generations, cities_dict, PopulationSize):
    n_cities = len(cities_dict)
    names_list = list(cities_dict.keys())
    best_fitness = np.inf
    best_solution = None
    best_generation = 0
    best_fitness_history = []
    best_solutions = []

    for generation in range(n_generations):
        population = [np.random.choice(names_list, n_cities, replace=False) for _ in range(PopulationSize)]
        fitness_list = get_all_fitness(population, cities_dict)
        current_best_fitness = np.min(fitness_list)
        if current_best_fitness < best_fitness:
            best_fitness = current_best_fitness
            best_solution = population[np.argmin(fitness_list)]
            best_generation = generation
            best_solutions.append((best_generation, best_solution))

        if generation % 100 == 0:
            best_fitness_history.append((generation, best_fitness))
            print(f"Generation {generation}: Best Fitness = {best_fitness}")
    
    return best_solution, best_fitness, best_solutions
    
def plot_tours(best_solutions, cities_dict):
    """
    Generate a plot for each of the best solutions.

    Parameters:
    best_solutions (list): A list of tuples (generation, best_solution)
    cities_dict (dict): A dictionary mapping city names to their coordinates.

    Returns:
    None
    """
    # Define number of rows and columns for the subplot grid
    n_cols = 5
    n_rows = len(best_solutions) // n_cols + (len(best_solutions) % n_cols > 0)

    # Set the dimensions of each subplot (making it square)
    subplot_size = 5

    # Create figure with the overall size being proportional to the number of subplots
    fig, axs = plt.subplots(n_rows, n_cols, figsize=(n_cols*subplot_size, n_rows*subplot_size))

    # Flatten axs to make indexing easier
    axs = axs.flatten()

    for i, (generation, solution) in enumerate(best_solutions):
        # Get city coordinates in the order of the solution
        tour_coordinates = [cities_dict[city] for city in solution]

        # Add starting city to end to close the tour
        tour_coordinates.append(tour_coordinates[0])

        # Split coordinates into x and y
        x_coords, y_coords = zip(*tour_coordinates)

        # Plot the tour
        axs[i].plot(x_coords, y_coords, 'o-')

        # Evaluate fitness of solution and round to 2 decimal places
        fitness = round(fitness_eval(solution, cities_dict), 2)

        # Set the title of the subplot
        axs[i].set_title(f"Gen: {generation}, Fitness: {fitness}")
        
        # Set x and y axis limits
        axs[i].set_xlim([-5, 105])
        axs[i].set_ylim([-5, 105])
        
        # Equalize axis scales to create square plots
        axs[i].set_aspect('equal', adjustable='datalim')

    # Remove unused subplots
    for i in range(len(best_solutions), n_rows*n_cols):
        fig.delaxes(axs[i])

    # Adjust layout for better visuals
    fig.tight_layout()

    # Show the plot
    plt.show()